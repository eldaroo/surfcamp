import { NextRequest, NextResponse } from 'next/server';
import { config, isConfigValid, getWeTravelAccessToken } from '@/lib/config';
import { Pool } from 'pg';

// Database connection
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
});

export async function POST(request: NextRequest) {
  const client = await pool.connect();
  
  try {
    const body = await request.json();
    
    console.log('üì§ WeTravel API request received:', body);

    // üîÑ NEW: Support both old and new payload formats
    let wetravelPayload;
    let bookingData = null;
    
    // NEW FORMAT: { checkIn, checkOut, guests, roomTypeId, contactInfo, ... }
    if (body.checkIn && body.checkOut && body.contactInfo) {
      console.log('üìù New format detected - creating order first');
      
      const { checkIn, checkOut, guests, roomTypeId, contactInfo, selectedActivities } = body;
      
      // Calculate totals (simplified for now)
      const nights = Math.ceil((new Date(checkOut).getTime() - new Date(checkIn).getTime()) / (1000 * 60 * 60 * 24));
      const totalAmount = 100; // $1 for testing - you can implement real pricing
      
      // Save booking data
      bookingData = {
        checkIn,
        checkOut,
        guests,
        roomTypeId,
        contactInfo,
        selectedActivities,
        nights,
        totalAmount
      };
      
      // Create WeTravel payload from booking data
      const daysBeforeDeparture = Math.max(1, Math.ceil((new Date(checkIn).getTime() - Date.now()) / (1000 * 60 * 60 * 24)));
      
      wetravelPayload = {
        data: {
          trip: {
            title: "Surf & Yoga Retreat ‚Äì Santa Teresa",
            start_date: checkIn,
            end_date: checkOut,
            currency: "USD",
            participant_fees: "all"
          },
          pricing: {
            price: 1, // $1 for testing (totalAmount is already in cents)
            payment_plan: {
              allow_auto_payment: false,
              allow_partial_payment: false,
              deposit: 0,
              installments: [
                { 
                  price: 1, // $1 for testing
                  days_before_departure: daysBeforeDeparture
                }
              ]
            }
          },
          metadata: {
            customer_id: `cus_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            booking_data: bookingData
          }
        }
      };
    }
    // OLD FORMAT: { data: { trip: { start_date, end_date }, pricing: { price } } }
    else if (body.data?.trip?.start_date && body.data?.trip?.end_date && body.data?.pricing?.price) {
      console.log('üìù Legacy format detected - direct WeTravel call');
      wetravelPayload = body;
    }
    else {
      return NextResponse.json(
        { error: 'Missing required fields. Need either: (checkIn, checkOut, contactInfo) or (data.trip.start_date, data.trip.end_date, data.pricing.price)' },
        { status: 400 }
      );
    }

    // üíæ NEW: Save to database if we have booking data
    let orderId = null;
    let paymentId = null;
    
    if (bookingData) {
      await client.query('BEGIN');
      
      // Generate IDs
      orderId = `ord_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      paymentId = `pay_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      console.log(`üíæ Saving order ${orderId} and payment ${paymentId} to database`);
      
      // Save order
      await client.query(`
        INSERT INTO orders (
          id, status, total_amount, currency, 
          customer_name, customer_email, booking_data
        ) VALUES ($1, $2, $3, $4, $5, $6, $7)
      `, [
        orderId,
        'pending',
        bookingData.totalAmount,
        'USD',
        `${bookingData.contactInfo.firstName} ${bookingData.contactInfo.lastName}`,
        bookingData.contactInfo.email,
        JSON.stringify(bookingData)
      ]);
      
      // Save payment
      await client.query(`
        INSERT INTO payments (
          id, order_id, status, total_amount, currency, 
          payment_method, wetravel_data
        ) VALUES ($1, $2, $3, $4, $5, $6, $7)
      `, [
        paymentId,
        orderId,
        'pending',
        bookingData.totalAmount,
        'USD',
        'card',
        JSON.stringify({ created_from: 'payment_request', booking_data: bookingData })
      ]);
      
      // Add order/payment IDs to metadata
      wetravelPayload.data.metadata = {
        ...wetravelPayload.data.metadata,
        order_id: orderId,
        payment_id: paymentId
      };
      
      console.log('‚úÖ Order and payment saved to database');
    }

    // Verificar que tengamos la configuraci√≥n necesaria
    if (!isConfigValid()) {
      return NextResponse.json(
        { error: 'WeTravel API key not configured' },
        { status: 500 }
      );
    }

    // Obtener token de acceso de WeTravel
    const accessToken = await getWeTravelAccessToken();
    
    // Llamar a la API de WeTravel con el token de acceso
    console.log('üîó Calling WeTravel API with URL:', config.wetravel.apiUrl);
    console.log('üîë Using access token:', accessToken.substring(0, 20) + '...');
    console.log('üì§ Sending payload to WeTravel:', JSON.stringify(wetravelPayload, null, 2));
    
    const wetravelResponse = await fetch(config.wetravel.apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${accessToken}`,
      },
      body: JSON.stringify(wetravelPayload),
    });

    console.log('üì• WeTravel response status:', wetravelResponse.status);
    console.log('üì• WeTravel response headers:', Object.fromEntries(wetravelResponse.headers.entries()));

    if (!wetravelResponse.ok) {
      let errorData;
      try {
        errorData = await wetravelResponse.json();
        console.error('‚ùå WeTravel API error - Full response:', {
          status: wetravelResponse.status,
          statusText: wetravelResponse.statusText,
          headers: Object.fromEntries(wetravelResponse.headers.entries()),
          body: errorData
        });
      } catch (parseError) {
        console.error('‚ùå WeTravel API error - Could not parse response body:', parseError);
        const errorText = await wetravelResponse.text();
        console.error('‚ùå WeTravel API error - Raw response body:', errorText);
        errorData = { error: 'Could not parse error response' };
      }
      
      return NextResponse.json(
        { error: `WeTravel API error: ${errorData.message || errorData.error || wetravelResponse.statusText}` },
        { status: wetravelResponse.status }
      );
    }

    let wetravelData;
    try {
      wetravelData = await wetravelResponse.json();
      console.log('‚úÖ WeTravel API successful response - Full details:', {
        status: wetravelResponse.status,
        statusText: wetravelResponse.statusText,
        headers: Object.fromEntries(wetravelResponse.headers.entries()),
        body: wetravelData
      });
    } catch (parseError) {
      console.error('‚ùå WeTravel API error - Could not parse successful response body:', parseError);
      const errorText = await wetravelResponse.text();
      console.error('‚ùå WeTravel API error - Raw successful response body:', errorText);
      throw new Error('Could not parse WeTravel response');
    }

    // Extraer la URL de pago de la respuesta de WeTravel
    const paymentUrl = wetravelData.data?.trip?.url || wetravelData.payment_url || wetravelData.url;
    const tripId = wetravelData.data?.trip?.uuid || wetravelData.trip_id;
    
    console.log('üîó Extracted payment URL:', paymentUrl);
    console.log('üÜî Extracted trip ID:', tripId);
    
    // üíæ NEW: Update payment record with WeTravel response if we saved to DB
    if (bookingData && paymentId) {
      await client.query(`
        UPDATE payments SET 
          wetravel_data = $2,
          updated_at = NOW()
        WHERE id = $1
      `, [
        paymentId,
        JSON.stringify({
          created_from: 'payment_request',
          booking_data: bookingData,
          wetravel_response: wetravelData,
          payment_url: paymentUrl,
          trip_id: tripId,
          updated_at: new Date().toISOString()
        })
      ]);
      
      await client.query('COMMIT');
      console.log('‚úÖ Payment record updated with WeTravel response');
    }
    
    // Retornar la URL de pago generada
    const response = {
      success: true,
      payment_url: paymentUrl,
      trip_id: tripId,
      metadata: wetravelData.data || wetravelData.metadata,
      // Include DB IDs if created
      ...(orderId && { order_id: orderId }),
      ...(paymentId && { payment_id: paymentId })
    };
    
    console.log('üì§ Returning response:', { ...response, metadata: '[included]' });
    
    return NextResponse.json(response);

  } catch (error) {
    // Rollback transaction if it was started
    try {
      await client.query('ROLLBACK');
    } catch (rollbackError) {
      console.error('‚ùå Error rolling back transaction:', rollbackError);
    }
    
    console.error('‚ùå Error in WeTravel payment API:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  } finally {
    client.release();
  }
}
